import { DeductionStep, DerivedRules } from "../../../types/sharedTypes";
import {
  addBracketsIfNecessary,
  addDeductionStep,
  getSearchIndexInDS,
  getTopLevelNegation,
  getUsableKbFromDS,
  searchIfExistsAsShow,
  searchInArray,
  searchInDS,
  searchIndex,
  splitArray,
} from "../../helperFunctions/deductionHelperFunctions/deductionHelperFunctions";
import { ModernLogicDeductionStep } from "../../../types/modernLogic/types";
import checkMLKnowledgeBase from "../checkMLKnowledgeBase/checkMLKnowledgeBase";
import {
  addMLDeductionStep,
  closeDeductionStep,
  existsInMLDS,
  pushLocallyDeducedPremise,
} from "../helperFunctions/helperFunction";
import getNegation from "../../sharedFunctions/getNegation/getNegation";
import checkForContradictionExploitaion from "../../sharedFunctions/checkForContradictionExploitation/checkForContradictionExploitation";
import getDesiredConcFromAssumption from "../getDesiredConcFromAssumption/getDesiredConcFromAssumption";

const checkMLContradictionExploitation = (
  premise: string[],
  previousDeductionStepsArr: DeductionStep[],
  derivedRules: DerivedRules
): DeductionStep[] | false => {
  const deductionStepsArr = [...previousDeductionStepsArr];

  const negatedPremise = getTopLevelNegation(premise);

  if (searchInDS(deductionStepsArr, negatedPremise)) {
    return deductionStepsArr;
  }

  // if it already exists as a show statement in the deduction steps
  // then it should not be added again
  if (!searchIfExistsAsShow(deductionStepsArr, premise)) {
    addMLDeductionStep(deductionStepsArr, premise, null, null, true);
  }

  if (!searchInDS(deductionStepsArr, negatedPremise)) {
    addMLDeductionStep(deductionStepsArr, negatedPremise, "AID", null);
  }

  const contradictionSteps = checkForContradiction(
    deductionStepsArr,
    derivedRules
  );

  if (contradictionSteps) {
    closeDeductionStep(contradictionSteps, premise);
    return contradictionSteps;
  }
  // else {
  //   // this checks with the negation of each of the premise in the knowledge base and
  //   for (let i = knowledgeBase.length - 1; i >= 0; i--) {
  //     const premise = knowledgeBase[i];
  //     const negatedPremise = getTopLevelNegation(premise);

  //     const premiseObj: ModernLogicDeductionStep = {
  //       rule: null,
  //       from: null,
  //       obtained: negatedPremise,
  //       show: true,
  //       closed: null,
  //     };

  //     // if it already exists as a show statement in the deduction steps
  //     // then it should not be added again
  //     if (!existsInMLDS(deductionStepsArr, premiseObj)) {
  //       addMLDeductionStep(deductionStepsArr, negatedPremise, null, null, true);
  //       allDeductionsArray.push(negatedPremise);
  //       if (
  //         checkForContradiction(
  //           knowledgeBase,
  //           deductionStepsArr,
  //           allDeductionsArray
  //         )
  //       ) {
  //         closeDeductionStep(deductionStepsArr, negatedPremise);

  //         return true;
  //       }
  //     }
  //   }
  // }
  return false;
};

export default checkMLContradictionExploitation;

const checkForContradiction = (
  previousDeductionStepsArr: DeductionStep[],
  derivedRules: DerivedRules
) => {
  const deductionStepsArr = [...previousDeductionStepsArr];
  const knowledgeBase = getUsableKbFromDS(deductionStepsArr);
  for (let i = 0; i < knowledgeBase.length; i++) {
    const premise = knowledgeBase[i];

    const negatedPremise = getTopLevelNegation(premise);
    const bracketedPremise = addBracketsIfNecessary(premise);
    const obtained = [...bracketedPremise, "&", ...negatedPremise];

    if (searchInDS(deductionStepsArr, negatedPremise)) {
      addDeductionStep(
        deductionStepsArr,
        obtained,
        "Conjunction",
        `${getSearchIndexInDS(
          deductionStepsArr,
          premise
        )}, ${getSearchIndexInDS(deductionStepsArr, negatedPremise)}`
      );
      return deductionStepsArr;
    }

    const existsInAssumptionDS = getDesiredConcFromAssumption(
      negatedPremise,
      deductionStepsArr,
      derivedRules
    );

    if (existsInAssumptionDS) {
      // addDeductionStep(
      //   existsInAssumptionDS,
      //   obtained,
      //   "Conjunction",
      //   `${getSearchIndexInDS(
      //     existsInAssumptionDS,
      //     premise
      //   )}, ${getSearchIndexInDS(existsInAssumptionDS, negatedPremise)}`
      // );
      return existsInAssumptionDS;
    }

    const negatedPremiseSteps = checkMLKnowledgeBase(
      negatedPremise,
      deductionStepsArr,
      derivedRules
    );
    if (negatedPremiseSteps) {
      addDeductionStep(
        negatedPremiseSteps,
        obtained,
        "Conjunction",
        `${getSearchIndexInDS(
          negatedPremiseSteps,
          premise
        )}, ${getSearchIndexInDS(negatedPremiseSteps, negatedPremise)}`
      );
      return negatedPremiseSteps;
    }
  }
  return false;
};
