// import { DeductionStep } from "../../../types/sharedTypes";
// import {
//   addBracketsIfNecessary,
//   addDeductionStep,
//   getTopLevelNegation,
//   searchInArray,
//   searchIndex,
//   splitArray,
// } from "../../helperFunctions/deductionHelperFunctions/deductionHelperFunctions";
// import { ModernLogicDeductionStep } from "../../../types/modernLogic/types";
// import checkMLKnowledgeBase from "../checkMLKnowledgeBase/checkMLKnowledgeBase";
// import {
//   addMLDeductionStep,
//   closeDeductionStep,
//   existsInMLDS,
//   pushLocallyDeducedPremise,
// } from "../helperFunctions/helperFunction";
// import getNegation from "../../sharedFunctions/getNegation/getNegation";

// const checkMLContradictionExploitation = (
//   premise: string[],
//   knowledgeBase: string[][],
//   deductionStepsArr: ModernLogicDeductionStep[],
//   allDeductionsArray: string[][]
// ): boolean => {
//   const negatedPremise = getNegation(premise);

//   const premiseObj: ModernLogicDeductionStep = {
//     rule: null,
//     from: null,
//     obtained: premise,
//     show: true,
//     closed: null,
//   };

//   // if it already exists as a show statement in the deduction steps
//   // then it should not be added again
//   if (!existsInMLDS(deductionStepsArr, premiseObj)) {
//     addMLDeductionStep(deductionStepsArr, premise, null, null, true);
//     allDeductionsArray.push(premise);
//   }

//   const indirectAssumptioObj: ModernLogicDeductionStep = {
//     rule: "AID",
//     from: null,
//     obtained: negatedPremise,
//     show: false,
//     closed: null,
//   };

//   if (!existsInMLDS(deductionStepsArr, indirectAssumptioObj)) {
//     addMLDeductionStep(deductionStepsArr, negatedPremise, "AID", null);
//     pushLocallyDeducedPremise(
//       negatedPremise,
//       knowledgeBase,
//       allDeductionsArray
//     );
//   } else return false;

//   if (
//     checkForContradiction(knowledgeBase, deductionStepsArr, allDeductionsArray)
//   ) {
//     closeDeductionStep(deductionStepsArr, premise);

//     return true;
//   }
//   // else {
//   //   // this checks with the negation of each of the premise in the knowledge base and
//   //   console.log("it cameee tilllll hereee");
//   //   for (let i = knowledgeBase.length - 1; i >= 0; i--) {
//   //     console.log("ðŸš€ ~ knowledgeBase:", knowledgeBase);
//   //     const premise = knowledgeBase[i];
//   //     const negatedPremise = getTopLevelNegation(premise);
//   //     console.log("ðŸš€ ~ negatedPremise:", negatedPremise);

//   //     const premiseObj: ModernLogicDeductionStep = {
//   //       rule: null,
//   //       from: null,
//   //       obtained: negatedPremise,
//   //       show: true,
//   //       closed: null,
//   //     };

//   //     // if it already exists as a show statement in the deduction steps
//   //     // then it should not be added again
//   //     if (!existsInMLDS(deductionStepsArr, premiseObj)) {
//   //       addMLDeductionStep(deductionStepsArr, negatedPremise, null, null, true);
//   //       allDeductionsArray.push(negatedPremise);
//   //       if (
//   //         checkForContradiction(
//   //           knowledgeBase,
//   //           deductionStepsArr,
//   //           allDeductionsArray
//   //         )
//   //       ) {
//   //         closeDeductionStep(deductionStepsArr, negatedPremise);

//   //         return true;
//   //       }
//   //     }
//   //   }
//   // }
//   return false;
// };

// export default checkMLContradictionExploitation;

// const checkForContradiction = (
//   knowledgeBase: string[][],
//   deductionStepsArr: ModernLogicDeductionStep[],
//   allDeductionArr: string[][]
// ) => {
//   console.log("ðŸš€ ~ knowledgeBase:", knowledgeBase);
//   // TODO: Implement contradiction from reverse for
//   // plIndirectProof generator, since it is more effecient
//   // such that the premises are more complex than the simplified
//   // wffs obtained after expanding the knowledge base
//   for (let i = knowledgeBase.length - 1; i >= 0; i--) {
//     const premise = knowledgeBase[i];
//     console.log("ðŸš€ ~ premise:", premise);
//     const negatedPremise = getTopLevelNegation(premise);
//     const bracketedPremise = addBracketsIfNecessary(premise);
//     const obtained = [...bracketedPremise, "&", ...negatedPremise];

//     if (searchInArray(knowledgeBase, negatedPremise)) {
//       addMLDeductionStep(
//         deductionStepsArr,
//         obtained,
//         "Conjunction",
//         `${searchIndex(allDeductionArr, premise)}, ${searchIndex(
//           allDeductionArr,
//           negatedPremise
//         )}`
//       );
//       knowledgeBase.push(obtained);
//       return true;
//     }

//     if (
//       checkMLKnowledgeBase(
//         negatedPremise,
//         knowledgeBase,
//         allDeductionArr,
//         deductionStepsArr
//       )
//     ) {
//       addMLDeductionStep(
//         deductionStepsArr,
//         obtained,
//         "Conjunction",
//         `${searchIndex(allDeductionArr, premise)}, ${searchIndex(
//           allDeductionArr,
//           negatedPremise
//         )}`
//       );
//       knowledgeBase.push(obtained);
//       return true;
//     }
//   }
//   return false;
// };

export {};
