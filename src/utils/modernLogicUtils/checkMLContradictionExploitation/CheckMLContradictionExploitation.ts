import { DeductionStep } from "../../../types/sharedTypes";
import {
  addBracketsIfNecessary,
  addDeductionStep,
  getTopLevelNegation,
  searchInArray,
  searchIndex,
  splitArray,
} from "../../helperFunctions/deductionHelperFunctions/deductionHelperFunctions";
import { ModernLogicDeductionStep } from "../../../types/modernLogic/types";
import checkMLKnowledgeBase from "../checkMLKnowledgeBase/checkMLKnowledgeBase";
import {
  addMLDeductionStep,
  closeDeductionStep,
  existsInMLDS,
  pushLocallyDeducedPremise,
} from "../helperFunctions/helperFunction";
import getNegation from "../../sharedFunctions/getNegation/getNegation";

const checkMLContradictionExploitation = (
  premise: string[],
  knowledgeBase: string[][],
  deductionStepsArr: ModernLogicDeductionStep[],
  allDeductionsArray: string[][]
): boolean => {
  const negatedPremise = getNegation(premise);

  const premiseObj: ModernLogicDeductionStep = {
    rule: null,
    from: null,
    obtained: premise,
    show: true,
    closed: null,
  };

  // if it already exists as a show statement in the deduction steps
  // then it should not be added again
  if (!existsInMLDS(deductionStepsArr, premiseObj)) {
    addMLDeductionStep(deductionStepsArr, premise, null, null, true);
    allDeductionsArray.push(premise);
  }

  const indirectAssumptioObj: ModernLogicDeductionStep = {
    rule: "AID",
    from: null,
    obtained: negatedPremise,
    show: false,
    closed: null,
  };

  if (!existsInMLDS(deductionStepsArr, indirectAssumptioObj)) {
    addMLDeductionStep(deductionStepsArr, negatedPremise, "AID", null);
    pushLocallyDeducedPremise(
      negatedPremise,
      knowledgeBase,
      allDeductionsArray
    );
  } else return false;

  if (
    checkForContradiction(knowledgeBase, deductionStepsArr, allDeductionsArray)
  ) {
    closeDeductionStep(deductionStepsArr, premise);

    return true;
  }
  return false;
};

export default checkMLContradictionExploitation;

const checkForContradiction = (
  knowledgeBase: string[][],
  deductionStepsArr: ModernLogicDeductionStep[],
  allDeductionArr: string[][]
) => {
  // TODO: Implement contradiction from reverse for
  // plIndirectProof generator, since it is more effecient
  // such that the premises are more complex than the simplified
  // wffs obtained after expanding the knowledge base
  for (let i = knowledgeBase.length - 1; i > 0; i--) {
    const premise = knowledgeBase[i];
    const negatedPremise = getTopLevelNegation(premise);
    const bracketedPremise = addBracketsIfNecessary(premise);
    const obtained = [...bracketedPremise, "&", ...negatedPremise];

    if (searchInArray(knowledgeBase, negatedPremise)) {
      addMLDeductionStep(
        deductionStepsArr,
        obtained,
        "Conjunction",
        `${searchIndex(allDeductionArr, premise)}, ${searchIndex(
          allDeductionArr,
          negatedPremise
        )}`
      );
      knowledgeBase.push(obtained);
      return true;
    }

    if (
      checkMLKnowledgeBase(
        negatedPremise,
        knowledgeBase,
        allDeductionArr,
        deductionStepsArr
      )
    ) {
      addMLDeductionStep(
        deductionStepsArr,
        obtained,
        "Conjunction",
        `${searchIndex(allDeductionArr, premise)}, ${searchIndex(
          allDeductionArr,
          negatedPremise
        )}`
      );
      knowledgeBase.push(obtained);
      return true;
    }
  }
  return false;
};
