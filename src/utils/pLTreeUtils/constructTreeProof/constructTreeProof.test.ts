import TreeNode from "../treeNode/treeNode";
import constructTreeProof from "./constructTreeProof";

describe("constructTreeProof", () => {
  it("test 1", () => {
    const expected = {
      absurdity: false,
      branchingWff: true,
      data: ["t", "->", "s"],
      left: null,
      middle: {
        absurdity: false,
        branchingWff: true,
        data: ["q", "->", "y"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["~", "(", "p", "->", "r", ")"],
          left: null,
          middle: {
            absurdity: false,
            branchingWff: false,
            data: ["p"],
            left: null,
            middle: {
              absurdity: false,
              branchingWff: false,
              data: ["~r"],
              left: {
                absurdity: false,
                branchingWff: false,
                data: ["~t"],
                left: {
                  absurdity: false,
                  branchingWff: false,
                  data: ["~q"],
                  left: null,
                  middle: null,
                  orderNumber: 7,
                  originNumber: 2,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                middle: null,
                orderNumber: 6,
                originNumber: 1,
                primitive: true,
                right: {
                  absurdity: false,
                  branchingWff: false,
                  data: ["y"],
                  left: null,
                  middle: null,
                  orderNumber: 7,
                  originNumber: 2,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                unpacked: false,
              },
              middle: null,
              orderNumber: 5,
              originNumber: 3,
              primitive: true,
              right: {
                absurdity: false,
                branchingWff: false,
                data: ["s"],
                left: {
                  absurdity: false,
                  branchingWff: false,
                  data: ["~q"],
                  left: null,
                  middle: null,
                  orderNumber: 7,
                  originNumber: 2,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                middle: null,
                orderNumber: 6,
                originNumber: 1,
                primitive: true,
                right: {
                  absurdity: false,
                  branchingWff: false,
                  data: ["y"],
                  left: null,
                  middle: null,
                  orderNumber: 7,
                  originNumber: 2,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                unpacked: false,
              },
              unpacked: false,
            },
            orderNumber: 4,
            originNumber: 3,
            primitive: true,
            right: null,
            unpacked: false,
          },
          orderNumber: 3,
          originNumber: null,
          primitive: false,
          right: null,
          unpacked: true,
        },
        orderNumber: 2,
        originNumber: null,
        primitive: false,
        right: null,
        unpacked: true,
      },
      orderNumber: 1,
      originNumber: null,
      primitive: false,
      right: null,
      unpacked: true,
    };

    expect(constructTreeProof(["t -> s", "q -> y"], "p -> r")).toEqual(
      expected
    );
  });

  it("test 2", () => {
    const expected = {
      absurdity: false,
      branchingWff: true,
      data: ["p", "->", "q"],
      left: null,
      middle: {
        absurdity: false,
        branchingWff: true,
        data: ["q", "->", "r"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["~", "(", "p", "->", "r", ")"],
          left: null,
          middle: {
            absurdity: false,
            branchingWff: false,
            data: ["p"],
            left: null,
            middle: {
              absurdity: false,
              branchingWff: false,
              data: ["~r"],
              left: {
                absurdity: true,
                branchingWff: false,
                data: ["~p"],
                left: null,
                middle: null,
                orderNumber: 6,
                originNumber: 1,
                primitive: true,
                right: null,
                unpacked: false,
              },
              middle: null,
              orderNumber: 5,
              originNumber: 3,
              primitive: true,
              right: {
                absurdity: false,
                branchingWff: false,
                data: ["q"],
                left: {
                  absurdity: true,
                  branchingWff: false,
                  data: ["~q"],
                  left: null,
                  middle: null,
                  orderNumber: 7,
                  originNumber: 2,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                middle: null,
                orderNumber: 6,
                originNumber: 1,
                primitive: true,
                right: {
                  absurdity: true,
                  branchingWff: false,
                  data: ["r"],
                  left: null,
                  middle: null,
                  orderNumber: 7,
                  originNumber: 2,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                unpacked: false,
              },
              unpacked: false,
            },
            orderNumber: 4,
            originNumber: 3,
            primitive: true,
            right: null,
            unpacked: false,
          },
          orderNumber: 3,
          originNumber: null,
          primitive: false,
          right: null,
          unpacked: true,
        },
        orderNumber: 2,
        originNumber: null,
        primitive: false,
        right: null,
        unpacked: true,
      },
      orderNumber: 1,
      originNumber: null,
      primitive: false,
      right: null,
      unpacked: true,
    };

    expect(constructTreeProof(["p -> q", "q -> r"], "p -> r")).toEqual(
      expected
    );
  });

  /**
   * FIXED: Jest was throwing error which showed wrong type assertion
   * but it was a problem with a missing bracket in the middle tree node of
   * the primary one i.e.,data: [
          "~",
          "(",
          "(",
          "p",
          "->",
          "r",
          ")",
          "|",
          "(",
          "q",
          "->",
          "r",
          ")",
          ")",
        ],
   */
  it("test 3", () => {
    const expected = {
      absurdity: false,
      branchingWff: true,
      data: ["(", "p", "&", "q", ")", "->", "r"],
      left: null,
      middle: {
        absurdity: false,
        branchingWff: false,
        data: [
          "~",
          "(",
          "(",
          "p",
          "->",
          "r",
          ")",
          "|",
          "(",
          "q",
          "->",
          "r",
          ")",
          ")",
        ],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["~", "(", "p", "->", "r", ")"],
          left: null,
          middle: {
            absurdity: false,
            branchingWff: false,
            data: ["~", "(", "q", "->", "r", ")"],
            left: null,
            middle: {
              absurdity: false,
              branchingWff: false,
              data: ["p"],
              left: null,
              middle: {
                absurdity: false,
                branchingWff: false,
                data: ["~r"],
                left: null,
                middle: {
                  absurdity: false,
                  branchingWff: false,
                  data: ["q"],
                  left: null,
                  middle: {
                    absurdity: false,
                    branchingWff: false,
                    data: ["~r"],
                    left: {
                      absurdity: false,
                      branchingWff: true,
                      data: ["~", "(", "p", "&", "q", ")"],
                      left: {
                        absurdity: true,
                        branchingWff: false,
                        data: ["~p"],
                        left: null,
                        middle: null,
                        orderNumber: 10,
                        originNumber: 9,
                        primitive: true,
                        right: null,
                        unpacked: false,
                      },
                      middle: null,
                      orderNumber: 9,
                      originNumber: 1,
                      primitive: false,
                      right: {
                        absurdity: true,
                        branchingWff: false,
                        data: ["~q"],
                        left: null,
                        middle: null,
                        orderNumber: 10,
                        originNumber: 9,
                        primitive: true,
                        right: null,
                        unpacked: false,
                      },
                      unpacked: true,
                    },
                    middle: null,
                    orderNumber: 8,
                    originNumber: 4,
                    primitive: true,
                    right: {
                      absurdity: true,
                      branchingWff: false,
                      data: ["r"],
                      left: null,
                      middle: null,
                      orderNumber: 9,
                      originNumber: 1,
                      primitive: true,
                      right: null,
                      unpacked: false,
                    },
                    unpacked: false,
                  },
                  orderNumber: 7,
                  originNumber: 4,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                orderNumber: 6,
                originNumber: 3,
                primitive: true,
                right: null,
                unpacked: false,
              },
              orderNumber: 5,
              originNumber: 3,
              primitive: true,
              right: null,
              unpacked: false,
            },
            orderNumber: 4,
            originNumber: 2,
            primitive: false,
            right: null,
            unpacked: true,
          },
          orderNumber: 3,
          originNumber: 2,
          primitive: false,
          right: null,
          unpacked: true,
        },
        orderNumber: 2,
        originNumber: null,
        primitive: false,
        right: null,
        unpacked: true,
      },
      orderNumber: 1,
      originNumber: null,
      primitive: false,
      right: null,
      unpacked: true,
    };
    expect(
      constructTreeProof(["( p & q ) -> r"], "(p -> r) | ( q -> r )")
    ).toEqual(expected);
  });
  it("test 4 --destructuring test 3", () => {
    const expected = {
      absurdity: false,
      branchingWff: true,
      data: ["(", "p", "&", "q", ")", "->", "r"],
      left: null,
      middle: {
        absurdity: false,
        branchingWff: false,
        data: ["~", "(", "p", "->", "r", ")"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["p"],
          left: null,
          middle: {
            absurdity: false,
            branchingWff: false,
            data: ["~r"],
            left: {
              absurdity: false,
              branchingWff: true,
              data: ["~", "(", "p", "&", "q", ")"],
              left: {
                absurdity: true,
                branchingWff: false,
                data: ["~p"],
                left: null,
                middle: null,
                orderNumber: 6,
                originNumber: 5,
                primitive: true,
                right: null,
                unpacked: false,
              },
              middle: null,
              orderNumber: 5,
              originNumber: 1,
              primitive: false,
              right: {
                absurdity: false,
                branchingWff: false,
                data: ["~q"],
                left: null,
                middle: null,
                orderNumber: 6,
                originNumber: 5,
                primitive: true,
                right: null,
                unpacked: false,
              },
              unpacked: true,
            },
            middle: null,
            orderNumber: 4,
            originNumber: 2,
            primitive: true,
            right: {
              absurdity: true,
              branchingWff: false,
              data: ["r"],
              left: null,
              middle: null,
              orderNumber: 5,
              originNumber: 1,
              primitive: true,
              right: null,
              unpacked: false,
            },
            unpacked: false,
          },
          orderNumber: 3,
          originNumber: 2,
          primitive: true,
          right: null,
          unpacked: false,
        },
        orderNumber: 2,
        originNumber: null,
        primitive: false,
        right: null,
        unpacked: true,
      },
      orderNumber: 1,
      originNumber: null,
      primitive: false,
      right: null,
      unpacked: true,
    };

    expect(constructTreeProof(["( p & q ) -> r"], "p -> r")).toEqual(expected);
  });

  /**
   *  TEST FOR VALIDITY
   *  BY CHANGING THE RETURN VALUE
   *  FOR NOW
   */
  it.skip("test validity", () => {
    const expected = true;

    expect(
      constructTreeProof(["(p | (q & r))"], "((p | q) & (p | r))")
    ).toEqual(expected);
  });
});

describe("report-id:fj1HpoqH9PgWRG8CaHTh", () => {
  const expected = {
    absurdity: false,
    branchingWff: true,
    data: ["H", "<->", "~", "(", "I", "|", "J", ")"],
    left: null,
    middle: {
      absurdity: false,
      branchingWff: true,
      data: ["I", "|", "~H"],
      left: null,
      middle: {
        absurdity: false,
        branchingWff: false,
        data: ["H"],
        left: {
          absurdity: false,
          branchingWff: false,
          data: ["H"],
          left: null,
          middle: {
            absurdity: false,
            branchingWff: false,
            data: ["~", "(", "I", "|", "J", ")"],
            left: {
              absurdity: false,
              branchingWff: false,
              data: ["I"],
              left: null,
              middle: {
                absurdity: false,
                branchingWff: false,
                data: ["~I"],
                left: null,
                middle: {
                  absurdity: true,
                  branchingWff: false,
                  data: ["~J"],
                  left: null,
                  middle: null,
                  orderNumber: 9,
                  originNumber: 5,
                  primitive: true,
                  right: null,
                  unpacked: false,
                },
                orderNumber: 8,
                originNumber: 5,
                primitive: true,
                right: null,
                unpacked: false,
              },
              orderNumber: 7,
              originNumber: 2,
              primitive: true,
              right: null,
              unpacked: false,
            },
            middle: null,
            orderNumber: 5,
            originNumber: 1,
            primitive: false,
            right: {
              absurdity: true,
              branchingWff: false,
              data: ["~H"],
              left: null,
              middle: null,
              orderNumber: 7,
              originNumber: 2,
              primitive: true,
              right: null,
              unpacked: false,
            },
            unpacked: true,
          },
          orderNumber: 4,
          originNumber: 1,
          primitive: true,
          right: null,
          unpacked: false,
        },
        middle: null,
        orderNumber: 3,
        originNumber: null,
        primitive: true,
        right: {
          absurdity: false,
          branchingWff: false,
          data: ["~H"],
          left: null,
          middle: {
            absurdity: true,
            branchingWff: true,
            data: ["I", "|", "J"],
            left: null,
            middle: null,
            orderNumber: 6,
            originNumber: 1,
            primitive: false,
            right: null,
            unpacked: true,
          },
          orderNumber: 4,
          originNumber: 1,
          primitive: true,
          right: null,
          unpacked: false,
        },
        unpacked: false,
      },
      orderNumber: 2,
      originNumber: null,
      primitive: false,
      right: null,
      unpacked: true,
    },
    orderNumber: 1,
    originNumber: null,
    primitive: false,
    right: null,
    unpacked: true,
  };

  it("complete report", () => {
    expect(constructTreeProof(["H<->~(I|J)", "I|~H"], "~H")).toEqual(expected);
  });

  it("testing negated biConditional", () => {
    const expected = {
      absurdity: false,
      branchingWff: true,
      data: ["A", "<->", "B"],
      left: {
        absurdity: false,
        branchingWff: false,
        data: ["A"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["B"],
          left: null,
          middle: null,
          orderNumber: 3,
          originNumber: 1,
          primitive: true,
          right: null,
          unpacked: false,
        },
        orderNumber: 2,
        originNumber: 1,
        primitive: true,
        right: null,
        unpacked: false,
      },
      middle: null,
      orderNumber: 1,
      originNumber: null,
      primitive: false,
      right: {
        absurdity: false,
        branchingWff: false,
        data: ["~A"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["~B"],
          left: null,
          middle: null,
          orderNumber: 4,
          originNumber: 1,
          primitive: true,
          right: null,
          unpacked: false,
        },
        orderNumber: 2,
        originNumber: 1,
        primitive: true,
        right: null,
        unpacked: false,
      },
      unpacked: true,
    };

    expect(constructTreeProof([], "~(A<->B)")).toEqual(expected);
  });

  it("testing biconditional", () => {
    const expected = {
      absurdity: false,
      branchingWff: true,
      data: ["~", "(", "A", "<->", "B", ")"],
      left: {
        absurdity: false,
        branchingWff: false,
        data: ["A"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["~B"],
          left: null,
          middle: null,
          orderNumber: 4,
          originNumber: 1,
          primitive: true,
          right: null,
          unpacked: false,
        },
        orderNumber: 2,
        originNumber: 1,
        primitive: true,
        right: null,
        unpacked: false,
      },
      middle: null,
      orderNumber: 1,
      originNumber: null,
      primitive: false,
      right: {
        absurdity: false,
        branchingWff: false,
        data: ["~A"],
        left: null,
        middle: {
          absurdity: false,
          branchingWff: false,
          data: ["B"],
          left: null,
          middle: null,
          orderNumber: 5,
          originNumber: 1,
          primitive: true,
          right: null,
          unpacked: false,
        },
        orderNumber: 2,
        originNumber: 1,
        primitive: true,
        right: null,
        unpacked: false,
      },
      unpacked: true,
    };
    expect(constructTreeProof([], "A<->B")).toEqual(expected);
  });
});
